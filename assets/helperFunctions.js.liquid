(function () {

window.hbsApp = {} ;
var hbsApp = window.hbsApp

  /****************************************************************************
    UNIVERSAL
  ****************************************************************************/

  // special console log, first argument is true or false, meaning to be displayed or not
  // this is because we can't set break points in chrome debugger, so have to use console logs to debug
  hbsApp.cLog = function (toLog) {
    if (toLog === true) {
      var args = Array.isArray(arguments[1]) ? arguments[1] : Array.prototype.slice.call(arguments, 1);
      console.log.apply(console, args);
    }
  };

  // converts an rgba string to an array of returns an array of 3 or 4 values
	hbsApp.rgbaToVal = function (rgbaStr) {
    rgbaStr = rgbaStr || "rgba(255, 255, 255)";
		var rgba = [];
		var parsed = rgbaStr.match(/\d+/g);
		for (var i = 0; i < parsed.length; i++) { 
			rgba.push(parseInt(parsed[i], 10));
		}
		return rgba;
	}

  // this is for checking if the size of the viewport as classified by bootstrap (xs, sm, md, lg)
  hbsApp.rgbaToName = function (rgbaStr) {
  	var rgba = hbsApp.rgbaToVal(rgbaStr);
  	var red = rgba[0];
  	var green = rgba[1];
  	var blue = rgba[2];
  	var alpha = rgba[3];

  	if (red > 100 && green > 100 && blue > 100) {
  		return "lg";
  	} else if (red > 100) {
  		return "xs";
  	} else if (green > 100) {
  		return "sm";
  	} else {
  		return "md";
  	}
  };

  // returns 'xs', 'sm', 'md', or 'lg', depending on the current viewport. this is based on a hidden div in the header that changes background color according to css media queries
  hbsApp.getMobileCheck = function () {
	  return hbsApp.rgbaToName($('.mobileCheck', hbsApp.headers).css('background-color'));
  };

  // converts a string of comma separated strings (default) to an array of numbers
  hbsApp.numStrToArray = function (str, delimiter) {
    delimiter = delimiter || ",";

    var array = str.split(delimiter);
    array.forEach(function (el, index, array) {
      array[index] = parseInt(el, 10);
    });

    return array;
  };

  /*
    check if images are still loading
    // timesChecked specifies max amount of time this function will run, just in case an image can't be found, the page won't stop loading
    // same as .load?
  */
  hbsApp.checkImgLoading = function (imageElements, callback, args, context, timesChecked) {
    var interval = 300;
    var toLog = false;
  	timesChecked = (timesChecked === undefined ? 40 : timesChecked);
    hbsApp.cLog(toLog, 'timesChecked orig: ', timesChecked);
    hbsApp.cLog(toLog, 'checkImgLoading: ', imageElements, callback, args, context, timesChecked);
  	if (timesChecked > 0) {
	    imageElements = imageElements || $('img');
	    context = context || null;

	  	filtered = imageElements.filter(function (index) {
	  		return this.naturalHeight === 0 || this.naturalWidth === 0;
	  	});

	  	// all images are loading / have a size
	  	if (filtered.length === 0) {
        hbsApp.cLog(toLog, 'timesChecked total loops: ', 40 - timesChecked, ', at', interval, 'ms / loop');
	  		hbsApp.imagesLoading = true;
	  		callback.apply(context, args);

	  	// not all images are loading / received size yet
	  	} else {
	  		var images = filtered;
	  		// for (var i = 0; i < images.length; i++) { hbsApp.cLog(toLog, 'img' + i, images[i].src, images[i].naturalHeight)}
	  		hbsApp.imagesLoading = false;
        hbsApp.cLog(toLog, 'timesChecked loops left: ', timesChecked);
	  		setTimeout(function () {
	  			hbsApp.checkImgLoading(filtered, callback, args, context, timesChecked-1);
	  		}, interval);
	  	}
  	}
  };

  /*
    return the container, strips away the $() wrap
  */
  hbsApp.getContainerDOM = function () {
    var container = $('.container');
    if (container.length > 0) {
      return container[0];
    } else {
      container = $('.container-fluid');
    }

    if (container.length > 0) {
      return container[0];
    } else {
      container = $('#page_container');
    }

    if (container.length > 0) {
      return container[0];
    } else {
      return null;
    }
  };

  /*
    return the type of container, either: "container", "container-fluid", or "null"
  */
  hbsApp.getContainerType = function (container) {
    if ($(container).hasClass('container')) { return '.container'; }
    else if ($(container).hasClass('container-fluid')) { return '.container-fluid'; }
    else { return "#page_container"; }
  };

  // this is one layer deep, there's usually some separator on the pages
  // container :: is where everything is contained, the items to be toggled mixed with other elements
  // toggle :: a class to be toggled OFF
  // before :: starting from the last child, we will toggle the specified class off UNTIL with the 'before' limiter
  hbsApp.toggleSeparator = function (container, toggle, before) {
    var children = $(container).children();
    for (var i = children.length-1; i >= 0; i--) {
      var child = children[i];
      // we only want to toggle separator elements AFTER the category elements
      if ($(child).hasClass(before)) {
        return;
      }

      if ($(child).hasClass(toggle)) {
        $(child).toggleClass(toggle);
      }
    }
  };

  // convert a string to a regular expressions, defaults to search for =string=
  // can take 2 optional args, specifying the start and end regular expression
  hbsApp.makeRE = function (string, reStart, reEnd) {
    reStart = reStart || "=\\s*";
    reEnd = reEnd || "\\**\\s*="
    return new RegExp(reStart + string + reEnd);
  };

  // takes an array of strings that are classes to regex match to in Shopify's description input box
  // e.g. ['description'] will return a new array of regex: ['=\s*sdescription\s*=']
  hbsApp.toRE = function (array) {
    var keys = array;
    var results = [];

    if (!Array.isArray(array)) {
      keys = Object.keys(array);
    }
    for (var i = 0; i < keys.length; i++) {
      results.push(hbsApp.makeRE(keys[i]));
    }
    return results;
  };

  // extract returns an object with properties that match the 'targets' parameter
  // the 'targets' parameter is an array of keywords, e.g.: ['description', 'events'];
  // the 'targetsRE' parameter is an array of targets elements that have been converted to regular expressions
  /* 
    For example, if a collection/page/product/blog's content/description on Shopify looks like this:

    Hello, this is just some description of the product

    =special=
    This text is something special

    =input=
    This text is also something different

    ----------------------------------------------------------------------------
    The above will return an object: {
      special: "<div class="special"><p> This text is something special </p></div>",

      input: "<div class="input"><p>This text is also something different</p></div>"
    }
  */
  hbsApp.extract = function (html, targets, targetsRE) {
    // html description might just be a string without html tags, if so, then we have to create a dom container for it first
    // it is very strange that Shopify does give html elements if the product description doesn't have a return
    var dom = html;

    if (typeof html === 'string' && html.search(/<\/*\w*\/*>/) < 0) {
      dom = $('<p></p>').text(html);
    }

    var children = $(dom);
    var appendTarget = null;
    var skip = true;
    var keys = targets;

    if (!Array.isArray(targets)) {
      keys = Object.keys(targets);
    }

    // create an empty div to hold dom elements that match/fall under the targets we are looking for
    results = [];

    hbsApp.children = children;

    // if a regex match is found through targetsRE, set the result objects's KEY as the original non-regexp string ('keys'), then set the VALUE as 
    // the 'skip' variable is to make sure the =string= node itself is NOT appended to anything, and skipped over
    var nonSpecialTextStart = true;
    var appendTarget = $('<div></div>');
    children.each(function (index) {
      skip = false;
      for (var i = 0; i < targetsRE.length; i++) {
        if ($(this).text().search(targetsRE[i]) >= 0) {
          var target = keys[i];
          appendTarget = $('<div></div>').addClass(keys[i]);

          var required = $(this).text().search(/\*/g) > 0;
          // this keeps track of what order these special fields appeared
          results.push({
            target: appendTarget,
            regex: target,
            options: {
              require: required
            }
          }); 
          skip = true;
          nonSpecialTextStart = false;
        } 
      }

      if (skip === false && nonSpecialTextStart) {
        results.push({
          target: appendTarget,
          regex: 'nonSpecial',
          options: {
          }
        });
        nonSpecialTextStart = false;
      }

      if (appendTarget && !skip) {
        appendTarget.append($(this));
      }

    });

    // return object, which consists of properties matching the target name, with values as an array of dom elements
    return results;
  };

  // this is a VERY simple generator that uses closure to keep track of state for different keys
  // incrementer starts at 0 when first invoked
  hbsApp.increment = (function () {
    var hash = {};

    return function (key, noIncrement) {
      if (hash[key] === undefined ) {
        hash[key] = 0;
      }
      return noIncrement ? hash[key] : hash[key]++;
    };

  })();


  /****************************************************************************
    SETTINGS: DEFAULT FONTS
  ****************************************************************************/
  hbsApp.loadGoogleFonts = function () {

  };

  /****************************************************************************
    HEADER
    *header*
  ****************************************************************************/
  // header navbar link is highlighted if the link's href matches the pathname of the URL
  hbsApp.navbarHighlight = function () {
    var pathname = window.location.pathname;
    $('#hbs_header .navbar-nav a').each(function (index) {
      if ($(this).attr('href') === pathname ) {
        $(this).addClass('header-currentpage');
      }
    });
  };

  /****************************************************************************
    PAGE SPECIFIC FUNCTIONS
  ****************************************************************************/

  /*---------------------------------------------------------------------------
    HOMEPAGE / FRONTPAGE / LANDING 
  ---------------------------------------------------------------------------*/
  /*
    homepage/frontpage column adjustment
    - right column always has to be gte the left column (height: fixed)
      + except on mobile (height: auto)
      + except when the left column is naturally shorter because of its contents
  */

  hbsApp.fpAdjustCol = function () {
    var toLog = true;
    if ($('#frontpage_container').length > 0) {
      hbsApp.cLog(toLog, 'fpAdjustCol executed');
      var leftCol = $(".frontpage_md_leftColumn")[0];
      var rightCol = $(".frontpage_md_rightColumn")[0];
      $(rightCol).css('height', 'auto');

      var leftColHeight = leftCol.scrollHeight;
      var rightColHeight = rightCol.scrollHeight;
      hbsApp.cLog(toLog, 'col left:', leftColHeight, ', right:',rightColHeight);

      if (hbsApp.mobileCheck === 'xs') {
        $(rightCol).css('height', 'auto');
        hbsApp.cLog(toLog, 'currently small?');
      } else if (rightColHeight < leftColHeight) {
        hbsApp.cLog(toLog, 'right before adj', rightCol.scrollHeight);
        $(rightCol).css('height', leftColHeight + 'px');
        hbsApp.cLog(toLog, 'right after adj', rightCol.scrollHeight);
      } else if (rightColHeight >= leftColHeight) {
        $(rightCol).css('height', 'auto');
      } else {
        $(rightCol).css('height', leftColHeight + 'px');
      }
    }
  };

  /*
    Set all images within the pulse feature to be centered
  */
  hbsApp.fp_centerPulseFeatureImg = function () {
    var pulseImages = $('.frontpage_md_pulseFeature img');
    pulseImages.addClass('center-block').parent().addClass('center-block');
  };

  /*
    this function breaks the description line in the upcoming events info container to a new line if it is determined that the picture size is too small in comparison to the info container
  */
  hbsApp.fp_adjustEventsInfoDescription = function (thresholdMax) {
    var toLog = false; // set to false to turn off debuggin console logs (breakpoints don't work on shopoify);
    var thresholdMax = thresholdMax || 1;

    // this checks only 'xs', but really, if someone transitions from 'xs' to other sizes, this sitll needs to be checked
    // therefore, if there is a transition from xs to any othersize, then we will run this again
    if (hbsApp.mobileCheck === 'xs' || hbsApp.mobileCheckPrevious === 'xs' && hbsApp.mobileCheck !== 'xs') {
      hbsApp.cLog(toLog, 'checking becaues XS');
      var eventWrapper = $('.eventWrapper');
      var pictures = $('.eventPicture', eventWrapper);
      var eventInfo = $('.eventInfo', eventWrapper);
      var infoCol = $('.col-xs-8', eventWrapper);
      var eventTemp = $('.event_descriptionTemp', eventWrapper);

      $('.frontpage_event_description').each(function (index) {
        var picHeight = parseInt($(pictures[index]).css('height'), 10);
        var descripHeight = parseInt($(this).css('height'), 10);
        var infoHeight = parseInt($(eventInfo[index]).css('height'), 10);

        // debugging purpose
        hbsApp.cLog(toLog, 'picHeight:', picHeight, ', descripHeight:', descripHeight, ', infoHeight:', infoHeight);
        hbsApp.cLog(toLog, 'this parent has class eventInfo:', $(this).parent().hasClass('eventInfo'));
        hbsApp.cLog(toLog, 'this parent has class event description temp:', $(this).parent().hasClass('event_descriptionTemp'));

        // if parent is eventInfo, that means it is contained within eventInfo, and we check the full height to see if it's more than the eventPicture
        if ($(this).parent().hasClass('eventInfo')) {
          hbsApp.cLog(toLog, 'parent is eventInfo. is infoHeight > picHeight?: ', infoHeight > picHeight);
          if (infoHeight > picHeight) {
            $(this).appendTo(eventTemp[index]);
          }
        // if parent is event_descriptionTemp. we change its width to the infoCol width, and check if the would be height PLUS the currentInfo height is greater than the picture height
        } else if ($(this).parent().hasClass('event_descriptionTemp')) {
          hbsApp.cLog(toLog, 'parent is descripTemp');
          var infoColWidth = $(infoCol[index]).css('width');
          var withinInfoHeight = parseInt($(this).css('width', infoColWidth).css('height'), 10);
          hbsApp.cLog(toLog, 'infoColWidth (px):', infoColWidth, 'withinInfoHeight (decimal):', withinInfoHeight)
          hbsApp.cLog(toLog, 'withinInfoHeight + infoHeight < picHeight * threshold', withinInfoHeight + infoHeight < picHeight * thresholdMax);
          // if it is greater, then we append it to the appropriate eventInfo index, else we revert it back to its original width
          if (withinInfoHeight + infoHeight < picHeight * thresholdMax) {
            $(this).appendTo(eventInfo[index]);
          } else {
          }
          $(this).css('width', 'auto');
        }

      });
    }
  }; // end of fp_adjustEventsInfoDescription

  /*---------------------------------------------------------------------------
    ABOUT US PAGE
    *aboutus*
  ---------------------------------------------------------------------------*/
  hbsApp.sortProfiles = function (hbsApp, order) {
    // detaching and reattaching a sorted grid of profile names
    var toLog = false;
    var breakerIndexes = [];
    var previousSibling = [];

    // get profile wrappers and detach from the dom, sort, then append back
    // HOWEVER only profiles after the first row should be sorted
    var afterFirstRow = hbsApp.numStrToArray(order)[0];
    var profileWrappers = $('.aboutus_execprofile_profile_wrapper').filter(function (index) {
      if (index > afterFirstRow-1) {
        return true;
      }
    }).detach();
    hbsApp.cLog(toLog, '\nnames before sort: ', $('.aboutus_execprofile_profile_name', profileWrappers).text());

    // sort the wrappers, mutates the original array
    profileWrappers.sort(function (profile1, profile2) {
      var name1 = $('.aboutus_execprofile_profile_name', $(profile1)).text().split(' ')[1];
      var name2 = $('.aboutus_execprofile_profile_name', $(profile2)).text().split(' ')[1];

      // alphabetical A-Z
      if (name1 < name2) {
        return -1;
      } else if (name1 > name2 ) {
        return 1
      } else {
        return 0;
      }
    });

    hbsApp.cLog(toLog, 'after sort: ', $('.aboutus_execprofile_profile_name', profileWrappers).text());

    // reinsert/reattach profile wrappers
    profileWrappers.appendTo($('.aboutus_execprofiles'));

  }; // end of sortProfiles

  hbsApp.createBreaks = function (orderStr) {

    var order = hbsApp.numStrToArray(orderStr, ',');
    var wrappers = $("#wrapAll .aboutus_execprofile_profile_wrapper");

    // all even numbers must have a division
    var two = "visible-sm-block two";
    wrappers.each(function (index) {
      if ( (index+1) % 2 === 0 ) {
        $(this).after($("<div></div>").addClass(two));
      }
    });

    // skip all numbers equal to 2, since the previous one has included it already
    for (var i = 0, index = 0; i < order.length; i++) {
      index += order[i];
      var divide = $('<div></div>').addClass('hidden-sm order');
      $(wrappers[index-1]).after(divide);
    }
  };

  /*---------------------------------------------------------------------------
    EVENTS PAGE
    *events*
  ---------------------------------------------------------------------------*/

  /*---------------------------------------------------------------------------
    COMMUNITY
    *community*
  ---------------------------------------------------------------------------*/
  /* 
    Functions related to the community page are about extracting the description and events list, and appending them to their respective fields
     String.prototype.search(regexp)
       =description= :: /=\s*description\s*=/
       =events=      :: /=\s*events\s*=/
  */

  hbsApp.community = {};
  hbsApp.community.categories = {};
  hbsApp.community.order = [];

  // keys to search for
  hbsApp.community.targets = ['description', 'events', 'image'];

  // specific logic for the community page, appends parsedHTML to different ID's
  // NOTE* hbsApp.community.categories 's data comes from javascript code in snippet/community.liquid:
  /*
    var cat = hbsApp.community.categories;
    cat["{{page.handle}}"] = {};
    cat["{{page.handle}}"].title = {{ page.title | json }};
    cat["{{page.handle}}"].content = {{ page.content | json }};
  */
  // basically, a NEW Shopify page has to be created for each community category (e.g. Arts, Service, etc.), and extract information from them.

  hbsApp.community.init = function () {
    var categories = hbsApp.community.categories;
    var targets = hbsApp.community.targets;
    var targetsRE = hbsApp.toRE(targets);

    for (var category in categories) {
      page = categories[category];
      var id = category;
      parsedHTML = hbsApp.extract(page.content, targets, targetsRE);

      for (var i = 0, len = parsedHTML.length; i < len; i++) {
        var obj = parsedHTML[i];
        $('#' + id + " ." + obj.regex).append(obj.target);        
      }
    }

  };

  /*---------------------------------------------------------------------------
    SPONSORS
    tags: *sponsors*
  ---------------------------------------------------------------------------*/


  /*---------------------------------------------------------------------------
    CATALOG / COLLECTIONS
    tags: *catalog* *collections* *products*
  ---------------------------------------------------------------------------*/

  hbsApp.collections = {};
  /*
    Catalog page adjust images just in case aspect ratio is not the same when merchant uploaded
    - look for images under the .collection-grid-row
    - useful for container-fluid    
  */
  hbsApp.catalogAdjustProductHeight = function (imageObj, hbsApp, imageSelector) {
    var toLog = true;
    imageSelector = imageSelector || '.collection-grid-row .product-image-wrapper img';
    if (!imageObj) {
      hbsApp.imageObj = {};
      var imageObj = hbsApp.imageObj;
      imageObj.images = $(imageSelector);
      imageObj.ideal = null;
      imageObj.unevenImages = [];
      imageObj.evenImages = [];
      imageObj.firstTime = true;
      imageObj.images.each(function (index) {
        if (!hbsApp.imageObj.ideal && this.naturalHeight % this.naturalWidth === 0) {
          hbsApp.imageObj.ideal = this;
          imageObj.evenImages.push(this);
        } else {
          if (this.naturalHeight % this.naturalWidth === 0) { 
            imageObj.evenImages.push(this)
          } else { 
            imageObj.unevenImages.push(this) 
          }
        }
      });
    }

    if (hbsApp.imageObj.ideal === null) {
      var idealHeight = hbsApp.catalogColWidth();
    } else {
      var idealHeight = $(hbsApp.imageObj.ideal).css({width: "100%", height: 'auto'}).css('height');
    }

    if (imageObj.firstTime) {
      $(imageObj.evenImages).css({width: '100%', height: 'auto'});
    }
  
    /* 
      if height/width is gt 1, then image is vertical rect, set height to fix, width to auto
      if height/width is lt 1, then image is horizontal rect, set width to fix, height to auto
    */
    $(imageObj.unevenImages).each(function (index) {
      var aspectRatio = this.naturalHeight / this.naturalWidth;

      // vertical rectangle
      if (aspectRatio > 1) {
        $(this).css({height: idealHeight, width: 'auto'});

      // horizontal rectangle
      } else {
        $(this).parent().css({height: idealHeight, width: 'auto'});
        $(this).css({height: 'auto', width: idealHeight});
        if (imageObj.firstTime) {
          $(this).parent().addClass('unevenHorizontalParent');
        }
      }
    });
    imageObj.firstTime = false;
  };

  /*
    calculate current column width, fixed or fluid will both have the same width once the dom is loaded
  */
  hbsApp.catalogColWidth = function (colSelector) {
    var toLog = true;
    colSelector = colSelector || '.product-grid-wrapper';
    var col = $(colSelector);
    if (col.length > 0) {
      col = $(col[0]);
      var finalWidth = parseInt(col.css('width'), 10);
      var checkStyles = ['border-left', 'border-right', 'padding-left', 'padding-right']
      for (var i = 0; i < checkStyles.length; i++) {
        finalWidth -= parseInt(col.css(checkStyles[i]), 10);
      }
      return finalWidth;
    }
  }

  /*
    Because img loading time is asychronous, the pictures will jitter, so we have to set all the pictures to an initial width
    - this executes ONCE only
  */
  hbsApp.catalogInitCol = function (idealHeight, imageSelector) {
    imageSelector = imageSelector || '.product-grid-wrapper img';
    $(imageSelector).css({height: idealHeight + 'px', width: 'auto'});
  };

  /* 
    pagination highlight
    - if the current page (url) is the same as a <a> link's href, then that link will have have an added class "activeLink"
  */

  hbsApp.collections.paginateHighlight = function () {
    var pathSearch = window.location.pathname + window.location.search;
    $("#paginate-nav a").each(function (index) {
      var href = $(this).attr('href');
      if (href === "#" || href === pathSearch) {
        $(this).addClass('activeLink');
      }
    });
  };

  hbsApp.collections.init = function () {
    var c = hbsApp.collections;

    // highlight pagination links that represent the current page
    c.paginateHighlight();
  };

  /*---------------------------------------------------------------------------
    PRODUCT / INDIVIDUAL
    tags: *product* *individual*
  ---------------------------------------------------------------------------*/
  // pictures can only be of a certain size, but we dont' know what ratio the pictures will be, so we give them predefined sizes
  hbsApp.product_adjustMaxDimensions = function (hbsApp) {
    hbsApp = hbsApp || window.hbsApp;
    var image = $('.product-page-productPicture img')[0];
    var aspectRatio = image.naturalWidth / image.naturalHeight;
    // if aspect ratio is square, then set max width
    if (aspectRatio === 1) {
      $(image).parent().addClass('square');

    // if aspect ratio is horizontal rectangle, then set max width
    } else if (aspectRatio > 1) {
      $(image).parent().addClass('horizRect');

    // if aspect ratio is vertical rectangle, then set max height
    } else if (aspectRatio < 1) {
      $(image).parent().addClass('vertRect');
    }
  }
/* ---------------- product selection from dropdown to separate fields --------------- */

  /*
    PLAN: 
    DATA
      append .js to pathname
      jquery get 

    DOM
      <div id="variantOptions">
        <p class="optionName"> option name </p>
        <ul class="option1">  <!-- list-style none, display: inline-block -->
          <li variant-data="s"> s </li>
          <li variant-data="m"> m </li>
          <li variant-data="l"> l </li>
        </ul>
      </div>

    data, currently highlighted: 

    LOGIC
      :: on li click, get current option, in the right combination, get ID number, update some form element
        <input type="hidden" name="id" value="VARIANT-ID">
        <input type="hidden" image-src="">

      :: if no default --> then just have an add button.

      :: visual price update


    NOTE**

    *remember* completely comment out current product select down mneu in chekcout-form

    *ONLY execute this function if variants > 0? 1?, so...during template creation...

    *if a variant is unavaible, make the addToCart button unclickable / preventDefault..
  */

  // split variants
  hbsApp.variants = {};

  // processData
  hbsApp.variants.processData = function (data) {
    var v = hbsApp.variants;
    v.hashID = {};
    v.idHash = {};
    v.options = {};
    v.options.len = data.options.length;
    v.options[0] = null;
    v.options[1] = null;
    v.options[2] = null;
    v.options.allowed = {};

    // this is setting up data for dom creation
    for (var i = 0; i < data.options.length; i++) {
      if (!v.options[i]) {
        var optionObj = data.options[i];
        v.options[i] = {};
        v.options[i].name = optionObj.name;
        v.options[i].position = optionObj.position;
        v.options[i].option = {};
        v.options[i].order = [];
        v.options[i].ul = null;
      }
    }

    // create a hash table for quick access, then record each variant's option so we have a master list
    for (var i = 0, len = data.variants.length; i < len; i++) {
      var variant = data.variants[i];

      v.hashID[variant.title] = variant;
      v.idHash[variant.id] = variant;

      // we will create a dictionary so that we can keep track of what order the options appear in
      // e.g. for clothing sizes, they should appear in whatver order the merchant specified: s, m, l

      for (var j = 0; j < data.options.length; j++) {
        var value = variant["option" + (j+1)];
        var masterKey = v.options[j].option; // this master key is for the order
        if (value) {
          if (!masterKey[value]) {
            v.options[j].order.push(value);
          }
          masterKey[value] = true;
        }

        if (!v.options.allowed[value]) {
          v.options.allowed[value] = {};
          v.options.allowed[value].self = {value: value, position: j };
          v.options.allowed[value].coexist = {};
        }

        for (var k = 0; k < data.options.length; k++) {
          if (k !== j) {
            v.options.allowed[value].coexist[variant["option" + (k+1)]] = true;
          }
        }

      }
    }

    // dirty is the FIRST thing to be checked, and has to be resolved
    // starts as true? so we can trigger it?
    v.dirty = null;

    // each time an item is changed, these are changed to reflect the product
    v.choice0 = null;
    v.choice1 = null;
    v.choice2 = null;

    // coexist. currently, once a user selects, that becomes the order in which to calculate a set
    v.setOrder = {
      first: null,
      second: null,
      third: null
    };

    v.setAllowed = null;

    // current variant
    v.current = {
      title: null,
      id: null,
      obj: null
    };
  };

  hbsApp.variants.getPosition = function (li) {
    return $(li).parent().attr('option-position');
  };

  hbsApp.variants.clearPrevious = function (choice) {
    if (choice) {
      choice.node.removeClass('selected');
    }
  };

  hbsApp.variants.getVariantviaOptions = function () {
    var variantString = Array.prototype.join.call(arguments, " / ");
    return hbsApp.variants.hashID[variantString];
  };

  // createDOM, called ONCE
  hbsApp.variants.createDOM = function (data) {
    var options = hbsApp.variants.options;
    var target = $("#product-add").prev();
    if (target.length < 1) {
      target = $(".product-vendor");
      if (target.length < 1) {
        target = $(".product-name");
      }
    }

    var master = $('<div></div>').attr('id', 'variant-table');

    for (var i = 0; i < options.len; i++) {
      var option = options[i];
      var div = $('<div></div>').addClass('variant-options');
      var small = $('<small></small>').addClass('variant-name').attr('variant-name', option.name).text(option.name);
      var ul = $('<ul></ul>').addClass('variant-list').attr('option-position', i);

      for (var j = 0; j < option.order.length; j++) {
        var li = $('<li></li>').attr('variant-option', option.order[j]).text(option.order[j]);
        ul.append(li);
      }
      option.ul = ul;
      master.append(div.append(small).append(ul));
    }

    // return a dom, also insert this new dom before the add cart button
    target.after(master);
    return master;
  };

  // for user input, there should be a certain order, which will limit what future choices can be

  hbsApp.variants.setPosition = function (li) {
    var key = {
      '0': 'first',
      '1': 'second',
      '2': 'third',
    };
    var v = hbsApp.variants;
    var options = v.options;
    var position = parseInt(v.getPosition(li), 10);
    var value = $(li).attr('variant-option')
    var coexist = options.allowed[value].coexist;
    for (var i = 0; i < v.options.len; i++) {
      if (!v.setOrder[key[i]]) {
        console.log("run three times max?");
        v.setOrder[key[i]] = {};
        v.setOrder[key[i]].coexist = coexist;
        v.setOrder[key[i]].position = position;
        v.setOrder[key[i]].self = options.allowed[value].self;
        return;
      // if
      } else if (v.setOrder[key[i]].position === position) {
        v.setOrder[key[i]].coexist = coexist;
        v.setOrder[key[i]].self = options.allowed[value].self;
        return;
      }
    }
  };

  // objA is considered first/remaining
  hbsApp.variants.set = function (objA, objB) {
    var results = {};
    for (var option in objB) {
      if (objA[option]) {
        results[option] = true
      }
    }
    return results;
  };

  hbsApp.variants.getRowValues = function (ul) {
    if (typeof ul === 'number') {
      ul = $("#variant-table ul")[ul];
    }
    var results = {};
    $(ul).children().each(function (index) {
      results[$(this).attr('variant-option')] = true;
    });

    return results;
  };

  /*
    test
  */

  /*
    i need a co exist function...not just if it can exist...a set function
  */
  hbsApp.variants.getSet = function () {
    var key = {
      "0": 'first',
      "1": 'second',
      "2": 'third'
    };
    var v = hbsApp.variants;
    var first = v.setOrder.first;
    var second = v.setOrder.second;
    var third = v.setOrder.third;
    v.setAllowed = {};

    if (first) {
      v.setAllowed[first.position] = v.getRowValues(first.position);
      for (var i = 0; i < v.options.len; i++) {
        if (i !== first.position) {
          v.setAllowed[i] = v.set(first.coexist, v.getRowValues(i));
        }
      }
      if (second) {
        for (var i = 0; i < v.options.len; i++) {
          if (i !== first.position && i !== second.position) {
            v.setAllowed[i] = v.set(first.coexist, second.coexist);
            // v.setAllowed[i] = v.set(v.setAllowed[second.position], v.getRowValues(i));
          }
        }

        if (third) {
          // v.setAllowed[third.position] = v.set(v.setAllowed[second.position], third.coexist);
        }
      }
    }

    return v.setOrder;
  };

  // when an option is clicked, we check if options belonging to other positions can coexist with it
  hbsApp.variants.availableToggle = function (target, ul, toggleClass) {
    var v = hbsApp.variants;
    var options = hbsApp.variants.options;
    var currentOption = options.allowed[target];
    var position = ul.attr('option-position');

    // we look at each element, and make sure it can exist with 
    ul.children().each(function (index) {
      var opt = $(this).attr('variant-option');
      // var allow = currentOption.coexist[opt]; // this should be a function
      var allow = v.setAllowed[position][opt];

      // if this item is not allowed to exist, we remove it's tag
      if (!allow) {
        $(this).addClass(toggleClass).removeClass('selected');
      } else {
        $(this).removeClass(toggleClass);
      }
    });
  };

  hbsApp.variants.getHash = function () {
    var results = {};
    results.options = [];
    results.hash = null;
    results.id = null;
    results.error = true;
    results.variant = null;
    var selected = $("#variant-table ul .selected");
    var v = hbsApp.variants;
    if (selected.length === v.options.len) {
      selected.each(function (index) {
        results.options.push($(this).attr('variant-option'));
      });

      results.hash = results.options.join(" / ");
      results.variant = v.hashID[results.hash];
      results.id = results.variant.id;
      results.error = false;
      return results;
    }

    return results;
  };

  /*
  */

  hbsApp.variants.addEvents = function (node) {
    var v = hbsApp.variants;
    var options = hbsApp.variants.options;
    $("#variant-table ul").on('click', 'li', function (event) {

      // 
      var position = v.getPosition($(this));
      var value = $(this).attr('variant-option');
      var choice = v['choice' + (position)];

      // 
      if (!$(this).hasClass('not-an-option') && !$(this).hasClass('selected')) {

        // 
        v.clearPrevious(choice);
        $(this).addClass('selected');
        v['choice' + position] = {node: $(this), value: value};

        // recalculate what is allowed to exist
        v.setPosition($(this));
        v.getSet();

        // this forloop will CHECK what is available to exist and toggle-off invalid options
        for (var i = 0; i < options.len; i++) {
          var position = parseInt($(this).parent().attr('option-position'), 10);
          if (i !== position) {
            v.availableToggle($(this).attr('variant-option'), options[i].ul, "not-an-option");
          }
        }

      } else if ($(this).hasClass('not-an-option')) {
      }

      var userChoice = v.getHash();
      if (userChoice.options.length === v.options.len && !userChoice.error) {
        console.log('hash: ', userChoice.hash);
        console.log('id: ', userChoice.id);

        // selection form update
        $('#product-variants select').val(userChoice.id).trigger('change');
      }

    });
  };
  
  // 3 tries, otherwise error
  hbsApp.variants.failCallback = function (data, triesLeft) {
    if (triesLeft > 0) {
      hbsApp.variants.ajax(productHandle, triesLeft-1);
    } else {
      console.log("Cannot get variant data, error: \n", data);
    }
  };

  // on success, our success function will call an init function that takes care of DATA, DOM, and LOGIC
  hbsApp.variants.successCallback = function (data) {
    if (data) {
      var v = hbsApp.variants;
      var parsed = typeof data === 'string' ? JSON.parse(data) : data;

      v.processData(parsed);
      var dom = v.createDOM(parsed);
      v.addEvents(dom);
      v.priceUpdate();
      v.populateSelections(data);
      v.preventAddToCart();
    }
  };

  hbsApp.variants.preventAddToCart = function () {
    var v = hbsApp.variants;
    $("#add").one('click', function (e) {
      if (v.getHash().error) {
        e.preventDefault;
        // add warning msg
        var msg = "Please select a style for each available option, thank you!"
        var small = $('<small></small>').attr('id', 'variant-warning').text(msg);
        $("#product-add").after(small);
      }

      // prevent adds if not complete
      $('#checkout-form').on('submit', function (e) {
        if (v.getHash().error) {
          e.preventDefault();
        }
      });
    });
  };

  hbsApp.variants.populateSelections = function (data) {
    var options = hbsApp.variants.options;
    var v = hbsApp.variants;
    var firstVariant = $('#product-variants select').val();
    var variantOptions = v.idHash[firstVariant].options;
    for (var i = 0; i < options.len; i++) {
      var selectOpt = variantOptions[i];
      var ul = options[i].ul;
      console.log('pos: ', i, ', ul: ', ul);
      var found = false
      $(ul).children().each(function (index) {
        if (!found && $(this).attr('variant-option') === selectOpt) {
          console.log('this: ', $(this).attr('variant-option'), ',select: ', selectOpt);
          $(this).click();
          found = true;
        }
      });
    }
  };

  hbsApp.formatMoney = function (number) {
    return (number/100).toFixed(2);
  };

  hbsApp.variants.priceUpdate = function () {
    // price update
    var v = hbsApp.variants;
    $("#product-variants select").on('change', function (e) {
      var id = $(this).val();
      var price = v.idHash[id].price;
      console.log('id: ', id, ', price: ', price);
      $("#product-price .product-price").text('$ ' + hbsApp.formatMoney(price));
    });
  };

  // split variants into separate selection menus
  hbsApp.variants.ajax = function (triesLeft) {
    // no, this is bad, i should construct the url
    // need {{ product.handle }}
    triesLeft = triesLeft === undefined ? 3 : triesLeft;
    var v = hbsApp.variants;

    var url = window.location.origin + window.location.pathname; 
    ajaxURL = url + ".js";
    console.log('this is URL', ajaxURL);

    // ajax call
    $.ajax({
      url: ajaxURL,
      method: "GET",
      success: function (data) {
        v.successCallback(data);
      },

      fail: function (error) {
        v.failCallback(error, triesLeft);
      }
    });
  };

  hbsApp.variants.init = function () {
    if (hbsApp.variants.use) {
      console.log('using variants transformer');
      hbsApp.variants.ajax();
    }
  };

/* ---------------- Variant selection connect to images --------------- */
  // variant images on enter
  // for left side variant images
  hbsApp.imageReplace = function (index, src) {
    src = src || $(this).attr('src');
    if ($('#main-image').attr('src') !== src) {
      $('.main-image').remove();
      var image = $('<img/>').attr('src', src);
      image.addClass('thumbnail').addClass('main-image');
      image.appendTo('.product-page-productPicture'); 
      console.log('after: ', image.attr('src'))
    }
  };

  // for selected variant
  hbsApp.imageSelect = function (index) {
    var src = $("option:selected", $(this)).attr('img-source');
    hbsApp.imageReplace(index, src);
    console.log('selected: ', src);
  };

  hbsApp.variantImageReplace = function () {
    $('.variant-image').on('mouseenter', hbsApp.imageReplace);
    $('.variant-image').on('click', hbsApp.imageReplace);
    $('#product-select').on('change', hbsApp.imageSelect);
  };

/* -------------------------------- */
  // read product.description and retrieve relevant information to insert into proper place and create fields
  hbsApp.addExtraFormFields = {};

  hbsApp.addExtraFormFields.targets = {
    'input-text': true,
    'input-checkbox': true,
    'note': true,
    'offsite': true,
    'comment': true
  };

  // takes a domNode, returns
  hbsApp.addExtraFormFields['input-text'] = function (domNode, options) {
    nodeText = $.trim(domNode.text());
    hbsApp['node' + hbsApp.increment('special')] = domNode;
    nodeID = "product-extra-input" + hbsApp.increment('formFields-input');
    var div = $('<div></div>').addClass('product-extra-input');

    var label = $('<label></label>').text(nodeText).attr({"for" : nodeID});
    var input = $('<input/>').attr({
      "id"   : nodeID, 
      "type" : "text",
      "name" : "properties[" + nodeText + "]"
    });

    // if form validation is required
    if (options.require) { 
      input.addClass('required'); 
      label.text( label.text() + "*" );
    }

    div.append(label).append(input);

    //domNode.remove();
    return div;
  };

  // returns 
  hbsApp.addExtraFormFields['note'] = function (domNode, options) {
    var div = $('<div></div>').addClass('product-extra-note');
    // var small = $("<small></small>").text(domNode.text());
    var small = $("<small></small>").append(domNode);

    // domNode.remove();
    return div.append(small);
  };

  hbsApp.addExtraFormFields['nonSpecial'] = function (domNode, options, fields) {
    domNode.addClass('nonSpecial');
    fields.productDescription.append(domNode);
  };

  hbsApp.addExtraFormFields['offsite'] = function (domNode) {
    var text = $.trim(domNode.children().first().text());
    var url = $.trim(domNode.children().first().next().text());
    
    if (url === "" || url === " ") {
      url = text;
    }

    if (text === "" || text === " " || text.search("www") >= 0 || text.search("http") >= 0) {
      text = "Purchase offsite";
    } 

    var anchor = $('<a></a>').attr('href', url).text(text);
    var div = $('<h4></h4>').addClass('offsite block-text').append(anchor);
    $('#add').before(div);
    $('#add').remove();
  };

  // this removes any special comments so that note can be left in product descriptions
  hbsApp.addExtraFormFields['comment'] = function (domNode) {
  }

  
  hbsApp.addExtraFormFields.init = function (descriptionSelector, afterNode) {
    descriptionSelector = descriptionSelector || "#product-description";
    var fields = hbsApp.addExtraFormFields;

    // based on interaction with other dom manipulation methods, certan dom elements may not exist on the final page
    // for example: if theere is an 'information' tag in the product, then there will be no element with a #product-price id
    afterNode = afterNode || "#product-price";
    fields.insertAfterThisNode = $(afterNode);
    if (fields.insertAfterThisNode.length < 1) {
      fields.insertAfterThisNode = $(".product-vendor");
      if (fields.insertAfterThisNode.length < 1) {
        fields.insertAfterThisNode = $(".product-name");
      }
    }

    // fields.html info comes from javascript code embedded in product-page-item
    var parsedHTML = hbsApp.extract(fields.html, fields.targets, hbsApp.toRE(fields.targets));

    // mutable properties
    fields.masterDiv = $('<div></div>').attr('id', 'product-extra').addClass('product-extra');
    fields.productDescription = $(descriptionSelector); // fields should be liquid | json ?

    // parsedHTML returns two things, an object or an index. we are using the index here to keep the order 
    parsedHTML.forEach(function (obj, index, array) {
      // nonSpecial means it belongs in the tab, and not in the checkout form area
      if (obj.regex === 'nonSpecial') {
        fields[obj.regex](obj.target, obj.options, fields);

      // if it is !nonSpecial, then it must be special
      } else {
        var fn = fields[obj.regex]
        if (fn) {
          var div = fn(obj.target, obj.options, fields);
          fields.masterDiv.append(div);
        }
      }
    });

    fields.insertAfterThisNode.after(fields.masterDiv);

    // Re append any remaing nonSpecial description information to the description tab


  }; // END / addExtraFormFields.init

})();